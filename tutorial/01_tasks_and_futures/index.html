<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

    

    <title>Tasks and Futures | Regent</title>
    
    <meta name="author" content="Stanford University">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <link href="/bootstrap/css/bootstrap.min.css" rel="stylesheet">
    <link href="/css/style.css" rel="stylesheet" type="text/css" media="all">
    <link href="/css/syntax.css" rel="stylesheet" type="text/css" media="all">

    <!-- Fav and touch icons -->
    <!-- Update these with your own images
      <link rel="shortcut icon" href="images/favicon.ico">
      <link rel="apple-touch-icon" href="images/apple-touch-icon.png">
      <link rel="apple-touch-icon" sizes="72x72" href="images/apple-touch-icon-72x72.png">
      <link rel="apple-touch-icon" sizes="114x114" href="images/apple-touch-icon-114x114.png">
    -->
  </head>
  <body>

    <header class="navbar navbar-static-top rg-nav" id="top" role="banner">
  <div class="container">
    <div class="navbar-header">
      <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target=".rg-navbar-collapse">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a href="/" class="navbar-brand">Regent</a>
    </div>
    <nav class="collapse navbar-collapse rg-navbar-collapse" role="navigation">
      <ul class="nav navbar-nav">
        
          
            
            
            
            <li class="">
              <a href="/install">Install</a>
            </li>
            
          
        
          
            
            
            
            <li class="">
              <a href="/tutorial">Tutorial</a>
            </li>
            
          
        
          
            
            
            
            <li class="">
              <a href="/reference">Reference</a>
            </li>
            
          
        
          
            
            
            
            <li class="">
              <a href="/resources">Resources</a>
            </li>
            
          
        
          
            
            
            
            <li class="">
              <a href="/publications">Publications</a>
            </li>
            
          
        
      </ul>

      <ul class="nav navbar-nav navbar-right">
        <li><a href="https://github.com/StanfordLegion/legion/tree/master/language">GitHub</a></li>
        <li><a href="/about">About</a></li>
      </ul>
    </nav>
  </div>
</header>


    <div class="container with-img-responsive">
  <div class="row">
    <div class="col-md-12">

      
        <h1 class="page-header">
          
            Tasks and Futures

          
          
        </h1>
      

      <p>This example introduces task launches and futures in Regent with a naive (but parallel) implementation of the Fibonacci numbers. This is not the fastest way to compute Fibonacci numbers, nor is it idiomatic Regent code, but it demonstrates some of the basic properties of Regent tasks. The complete code for this example follows at the bottom of the page and can also be found in the <a href="https://github.com/StanfordLegion/legion/tree/master/tutorial">GitHub repository</a>.</p>
<h2 id="tasks-and-parallelism">Tasks and Parallelism</h2>
<p><em>Tasks</em> are the basic unit of execution in Regent, like functions in traditional languages. In fact, the bodies of tasks literally execute sequentially. This means you can read the code for a task from top to bottom, as in a conventional programming language.</p>
<p>In Regent, when a task calls another task (called a <em>child task</em> or <em>subtask</em>), that task may execute in parallel. (The caller in this context is also known as a <em>parent task</em>.) Regent always ensures that the program behaves as if it were executing sequentially. Thus, when reading a program to understand what it does, it is sufficient to imagine that the tasks are simply running in order, one after another.</p>
<p>Behind the scenes, Regent analyzes the sequence of task calls to determine what is safe to execute in parallel. In the example below, the two calls to <code>fibonacci</code> below run in parallel because they do not <em>interfere</em> (i.e., there is no way for one task to influence the result of the other).</p>
<figure class="highlight">
<pre><code class="language-regent" data-lang="regent"><span class="kd">var</span> <span class="n">f1</span> <span class="o">=</span> <span class="n">fibonacci</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
<span class="kd">var</span> <span class="n">f2</span> <span class="o">=</span> <span class="n">fibonacci</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span></code></pre>
</figure>
<p>For the <code>fibonacci</code> tasks above, checking for interference is trivial: the parameters to the tasks are passed by-value, and Regent programs never contain mutable global variables. Thus there is no way for either task to modify state used in the other task (and thus no possibility of interference).</p>
<p>Regent does support mutable state, however. We’ll consider this (and how it results in potential interference) in later tutorials.</p>
<h2 id="futures-and-blocking-execution">Futures and Blocking Execution</h2>
<p>Here is the complete code for the <code>fibonacci</code> task. It takes one <code>int</code> argument, and returns an <code>int</code>. (The return type is inferred and thus need not be stated explicitly.) The body of the task stores the results of the two recursive calls in variables <code>f1</code> and <code>f2</code> and returns the sum of their values.</p>
<figure class="highlight">
<pre><code class="language-regent" data-lang="regent"><span class="k">task</span> <span class="nf">fibonacci</span><span class="p">(</span><span class="n">n</span> <span class="p">:</span> <span class="kt">int</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">then</span> <span class="k">return</span> <span class="mi">0</span> <span class="k">end</span>
  <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">then</span> <span class="k">return</span> <span class="mi">1</span> <span class="k">end</span>

  <span class="kd">var</span> <span class="n">f1</span> <span class="o">=</span> <span class="n">fibonacci</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
  <span class="kd">var</span> <span class="n">f2</span> <span class="o">=</span> <span class="n">fibonacci</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>

  <span class="k">return</span> <span class="n">f1</span> <span class="o">+</span> <span class="n">f2</span>
<span class="k">end</span></code></pre>
</figure>
<p>As noted above, the body of a Regent task literally executes sequentially. In the example above, that means the first call (to <code>fibonacci(n - 1)</code>) will be considered prior to the second call (<code>fibonacci(n - 2)</code>). Each task call is issued asynchronously. That is, execution proceeds in parallel to the parent task (assuming Regent can determine that this is safe to do). Thus the two substasks execute in parallel, despite the parent issuing the two calls in sequential order.</p>
<p>However, there are situations that can prevent parallel execution from occurring. In particular, because the parent executes the calls to substasks sequentially (even if the subtasks themselves may execute in parallel), if the parent task code blocks for any reason, Regent is unable to analyze any task calls subsequent to the point where it blocks. (At least, until the parent task is unblocked. But by that point the opportunity for parallelism has already passed.)</p>
<p>A concrete example of something that might block execution would be printing the value of <code>f1</code>:</p>
<figure class="highlight">
<pre><code class="language-regent" data-lang="regent"><span class="kd">var</span> <span class="n">f1</span> <span class="o">=</span> <span class="n">fibonacci</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">format</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="s2">"value of first fibonacci is {}"</span><span class="p">,</span> <span class="n">f1</span><span class="p">)</span> <span class="c1">-- blocks!</span>
<span class="kd">var</span> <span class="n">f2</span> <span class="o">=</span> <span class="n">fibonacci</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span></code></pre>
</figure>
<p>The second line in this snippet blocks, because it prints the result <code>f1</code> of the first task. In general, anything outside of Regent’s control (I/O, or anything written in C or another language) may inhibit parallelism. An easy way to work around this is to wrap the call to <code>println</code> in a task, as shown at the bottom of this section. Using the task “hides” the I/O from Regent, essentially giving Regent permission to reorder it with other tasks.</p>
<h2 id="why-the-code-blocks">Why the Code Blocks</h2>
<p>To understand more about why this code blocks, we need to describe an optimization performed by the Regent compiler. To be clear, this is <em>not</em> part of the Regent language, and in most cases, users need not think about it at all. But because it influences parallelism, it can be important to understand what Regent is doing to the code.</p>
<p>Behind the scenes, Regent maximizes parallelism by making each task return a <em>future</em>. Futures represent the results of tasks yet to be completed. In most cases, users don’t need to be concerned with futures: as noted above, as long as the program avoids passing any futures into I/O (or C functions), Regent will handle the parallelism automatically. Most Regent operations (tasks, arithmetic, even conditionals like <code>if</code> and <code>while</code>) can accept futures directly. The main exception is when the code invokes I/O or something written in a different language (like C). This happened above at the point where we passed <code>f1</code> into <code>format.println</code>.</p>
<p>Because this is an optimization by the Regent compiler, it can sometimes be hard to tell where a program will block. To help make this visible to the user, Regent provides a mode (enabled by the flag <code>-fpretty 1</code>) where the code for each task is printed back out, after applying all of Regent’s optimizations. This can be a helpful way to determine what optimizations are occurring and where potential serialization hazards may be in the code. If we run the above example with <code>-fpretty 1</code>, it produces something like:</p>
<figure class="highlight">
<pre><code class="language-regent" data-lang="regent"><span class="kd">var</span> <span class="n">f1</span> <span class="p">:</span> <span class="kt">future</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="o">=</span> <span class="n">fibonacci</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">format</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="s2">"value of first fibonacci is {}"</span><span class="p">,</span> <span class="n">__future_get_result</span><span class="p">(</span><span class="n">f1</span><span class="p">))</span>
<span class="kd">var</span> <span class="n">f2</span> <span class="p">:</span> <span class="kt">future</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="o">=</span> <span class="n">fibonacci</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span></code></pre>
</figure>
<p>Two things become obvious when we look at this code. First, Regent has changed both variables into futures. (Note that the <code>future</code> type is <em>not</em> one that users can write directly in Regent. It is purely an optimization of the compiler.) And second, Regent inserts a blocking call (<code>__future_get_result</code>) at the point where the value is about to be printed. This helps us pinpoint exactly where the code is going to block.</p>
<h2 id="putting-it-all-together">Putting it All Together</h2>
<p>Returning to our original example, <code>main</code> calls <code>fibonacci</code> in a loop. In order to avoid blocking on the call to <code>println</code>, the call is extracted into a task and called on the result of each <code>fibonacci</code> call. Thus the entire body of <code>main</code> will execute in parallel, with each <code>print_result</code> waiting on its corresponding <code>fibonacci</code>, but not otherwise blocking the execution of other <code>fibonacci</code> or <code>print_result</code> calls.</p>
<figure class="highlight">
<pre><code class="language-regent" data-lang="regent"><span class="k">task</span> <span class="nf">print_result</span><span class="p">(</span><span class="n">n</span> <span class="p">:</span> <span class="kt">int</span><span class="p">,</span> <span class="n">result</span> <span class="p">:</span> <span class="kt">int</span><span class="p">)</span>
  <span class="n">format</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="s2">"Fibonacci({}) = {}"</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>
<span class="k">end</span>

<span class="k">task</span> <span class="nf">main</span><span class="p">()</span>
  <span class="kd">var</span> <span class="n">num_fibonacci</span> <span class="o">=</span> <span class="mi">7</span>
  <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">num_fibonacci</span> <span class="k">do</span>
    <span class="n">print_result</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">fibonacci</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
  <span class="k">end</span>
<span class="k">end</span></code></pre>
</figure>
<h2 id="on-not-writing-idiomatic-code-in-regent">On (Not) Writing Idiomatic Code in Regent</h2>
<p>One last note before we move on: while this code is functionally correct and will even execute in parallel, it is <em>not</em> idiomatic Regent code.</p>
<p>First, the code above is very short. The <code>fibonacci</code> task essentially executes one <code>+</code> operation before returning. This means that, in addition to the algorithm itself being inefficient, this code is likely to experience very high overhead.</p>
<p>Recall that Regent automatically discovers parallelism between subtasks. This is a <em>dynamic</em> analysis, which means that it happens at runtime, while the parent task is executing. While Regent is heavily optimized to reduce the overhead of executing tasks, there will always be a certain amount of overhead that is inevitable. Thus, as a general rule, it is a good idea to construct larger tasks that perform more work at once, to counteract this overhead.</p>
<p>Second, the code uses scalar data types. There is nothing wrong with this per se. But most Regent programs operate on aggregate data structures. We will consider how to define bulk data in a future tutorial.</p>
<p>Third, the code uses recursion. While recursion may seem like a natural way to express nested parallelism, it is not the most idiomatic, or most efficient, way to express parallelism in Regent. Why? Because (as noted above) every task call has an overhead, recursion essentially delays the point at which Regent can discover the parallelism in a task. Thus it is normally better to write tasks in a loop-based style, so that a single parent task can enumerate all of the subtasks. Shallow levels of nesting are fine (say, at most two or three levels), but arbitrary recursion is usually a source of bottlenecks and thus best avoided in idiomatic Regent code.</p>
<p>We will return to the topic of writing idiomatic Regent code in future tutorials, after we discuss some additional features of the language.</p>
<h2 id="final-code">Final Code</h2>
<figure class="highlight">
<pre><code class="language-regent" data-lang="regent"><span class="k">import</span> <span class="s2">"regent"</span>

<span class="kd">local</span> <span class="n">format</span> <span class="o">=</span> <span class="nb">require</span><span class="p">(</span><span class="s2">"std/format"</span><span class="p">)</span>

<span class="k">task</span> <span class="nf">fibonacci</span><span class="p">(</span><span class="n">n</span> <span class="p">:</span> <span class="kt">int</span><span class="p">)</span> <span class="p">:</span> <span class="kt">int</span>
  <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">then</span> <span class="k">return</span> <span class="mi">0</span> <span class="k">end</span>
  <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">then</span> <span class="k">return</span> <span class="mi">1</span> <span class="k">end</span>

  <span class="kd">var</span> <span class="n">f1</span> <span class="o">=</span> <span class="n">fibonacci</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
  <span class="kd">var</span> <span class="n">f2</span> <span class="o">=</span> <span class="n">fibonacci</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>

  <span class="k">return</span> <span class="n">f1</span> <span class="o">+</span> <span class="n">f2</span>
<span class="k">end</span>

<span class="k">task</span> <span class="nf">print_result</span><span class="p">(</span><span class="n">n</span> <span class="p">:</span> <span class="kt">int</span><span class="p">,</span> <span class="n">result</span> <span class="p">:</span> <span class="kt">int</span><span class="p">)</span>
  <span class="n">format</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="s2">"Fibonacci({}) = {}"</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>
<span class="k">end</span>

<span class="k">task</span> <span class="nf">main</span><span class="p">()</span>
  <span class="kd">var</span> <span class="n">num_fibonacci</span> <span class="o">=</span> <span class="mi">7</span>
  <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">num_fibonacci</span> <span class="k">do</span>
    <span class="n">print_result</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">fibonacci</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
  <span class="k">end</span>
<span class="k">end</span>
<span class="n">regentlib</span><span class="p">.</span><span class="n">start</span><span class="p">(</span><span class="n">main</span><span class="p">)</span></code></pre>
</figure>
<h2 id="next-up">Next Up</h2>
<p>Continue to the <a href="/tutorial/02_index_tasks">next tutorial</a> to see how to use index launches optimize loops of parallel tasks.</p>

    </div>
  </div>
</div>


    <footer class="rg-footer" role="contentinfo">
  <div class="container">
    <p>&copy; 2023 Stanford University.</p>
    <p>Powered by <a href="http://jekyllrb.com/">Jekyll</a> and <a href="http://getbootstrap.com/">Bootstrap</a>.</p>

    <ul class="rg-footer-links muted">
      <li><a href="/">Home</a></li>
      <li>&middot;</li>
      
        
          <li><a href="/install">Install</a></li>
          <li>&middot;</li>
        
      
        
          <li><a href="/tutorial">Tutorial</a></li>
          <li>&middot;</li>
        
      
        
          <li><a href="/reference">Reference</a></li>
          <li>&middot;</li>
        
      
        
          <li><a href="/resources">Resources</a></li>
          <li>&middot;</li>
        
      
        
          <li><a href="/publications">Publications</a></li>
          <li>&middot;</li>
        
      
      <li><a href="https://github.com/StanfordLegion/legion/tree/master/language">GitHub</a></li>
      <li>&middot;</li>
      <li><a href="/about">About</a></li>
    </ul>
  </div>
</footer>


    <!-- Placed at the end of the document so the pages load faster -->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>
    <script src="/bootstrap/js/bootstrap.min.js"></script>

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-71475406-1', 'auto');
      ga('send', 'pageview');

    </script>
  </body>
</html>
